********** ROLLING HASH **********
The objective of the rolling hash is to hash a number in constant time and only if the hash collides with our substring hash, we compare them. If we have 0 hash collisions, that means we were able to represent all possible substrings within our space, and our time complexity becomes (n-k) + k, since we did k operations to hash our pattern, and n-k sliding hashes. Each time we got a matching hash number we knew that it would be our precise pattern. Say we have 50% hash collisions, that means 50% of the time, we have to do a k-complex check, so our time complexity is (n-k)*0.5k. As our hashing function drops in # of collisions, we approach some linear scale of complexity relative to n, since even if k were really big the tiny number we multiply it by often bounds it. This is just expected runtime though, not true worst case.

To hash, say letters, we can assign each letter a value, a=1, ..., z=26. We could then hash it like: h(abc) = 1*10^3 + 2*10^2 + 3*10^1 = 123. Here, our total possible hash range for length 3 is zzz, which would be 26*10^3 + 26*10^2 + 26 = 2886. But there are 26^3=17576 possible 3 letter strings, so we have collisions. For instance k=11 also collides with aa=11. If we want to maintain the pure no collision strategy, we need to use the 26th power as our base, so we would have 26*26^3 + 26*26^2 + 26*26^1 = 475228, but not all possible values are obtainable, for instance we could never have a value of 1, our smallest value would be 26 with the letter 'a'. Since we take steps of 26, we have 475228/26 = 18278 actual substrings (17576 of which are 3 letters). By using a higher base, we prevent collisions, but now we might introduce int overflow, so we start using mods. Prime mods give better distributions.

Say our alphabet is just a-k and we hash using powers of 10.
h(abcd) = 1234 % 113 = 104, and now we want to slide to bcde.
1234 % C is the same as (1000%C + 200%C + 30%C + 4%C) % C. This means that if we want to remove 1000, and determine what our hash is, all we have to do is subtract its contribuation. 1000%113 = 96, so our old hash, 104, minus 96, gives us our new hash, 8. Now we want to scale up the original number, 234->2340, and then mod it. Well (234*10) % C equals (234%C % 10%C) % C. We already have 234%C, which is 8. 10%C will always just be 10 since our scaling power will essentially always be under the mod. So really 2340%C is just (8*10) % C, which is 80! Finally, we add the new digit, 8, and mod again if needed.
But what if when we subtracted the contribution of 1000, it became negative? For instance say 1000%113 was 105, now when we remove it from 1234%C (104), we get -1. But 234%113 is not -1, it should be 112 (in this case). But lets try with the -1 as our new hash for 234 anyway. The next step is to multiply by 10, and we get -10. Since we might have made it too big if it were positive, we mod again, and -10%113 is 103, so it fixes itself. It would have been the same result had we used 112. Since a negative number modded gives a positive. In JS though, -10%113 gives a negative. So we need to add MOD. We can check if our result is <0 and then add MOD (or we can just always add MOD anyway).

But what if 10^3 or 10^2 is too large anyway? We can simplify it, since 10^2 % C is just (10%C * 10%C) % C using a mod pow function.

So the pattern is:
1) subtract contribution of old number
2) we may have a negative now, in JS, add mod
3) multiply by 10, then mod
4) add last digit, then mod

Also we call the has degree 'base' because we're basically converting an arbitrary amount of glyphs into some base number system so we can do math in that base number system. If we only had the letters a...j we can fit the math into base 10. So now we can do math operations like 123*10=1230. But if we want to include k, we should use base 11. So 123 in base 11 is 102, and when we multiply that 123*11 (1353) and convert to base 11, we get 1020. If we have 11 possible characters, of course we should use a base 11 system where each character has a weight by 11 to the power of something. The math properties are preserved so we can do rolling hashes still. We can use a smaller base than the number of glyphs we have, it just results in more collisions. For instance in base10 BB->22 is the same as AL (10+12). Also two strings of the same length can have a hash collision, even if our base is the # of glyphs, if the size of the strings are big enough such that there is overflow.

To see a really good implementation of a rolling hash, look at 718. It has a cached modpow function, a full implementation, and even an optimized implementation in terms of writing clean and concise code. We can do a fixed sliding window with just a single for loop vs. l and r pointers as well.

The rolling hash doesn't technically make something linear time, it basically makes it 1/buckets * n * k time, and the assumption is k is smaller than the number of buckets we hash to.

The rolling hash "shift" where we multiply everything by 10 or whatever the base is, is considered constant time, because we use MOD to keep it within a range. Since technically with an arbitrarily large number, multiplication becomes a function of n.