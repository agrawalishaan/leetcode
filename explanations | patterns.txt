kadane's - kadane's is very specifically a 'sliding window' technique where we iterate over an iterable and maintain a dp. If the dp doesn't meet some condition, we reset it in a way, effectively "moving" what would be our left pointer. Kadane's movement follows an inchworm, because when we don't meet a condition we reset the dp to some defined place. It's often easier to update the dp with the current index value immedaitely, then do computations with that, similar to how prefix sums usually include the current number as part of the prefix.

sliding window variable - these are more flexible, in that that the left pointer moves over by some other amount, depending on the problem. For instance finding the minimum size subarray that equals a certain sum (problem 209) consider [1, 3, 5] and our target is at least 6, once we hit [1,3,5] we keep decrementing from the left until we cannot any more. in sliding window we keep expanding until a condition is met (subarry has >= k sum) or broken (we have a repeating character), and then we shrink as much as needed (subarray too small) or (repeating character is gone). We could also just decrement from the left one at a time, and not increment the right.

two pointers - initialize two pointers that will be used to track or update things. Often, these are initialized at the left and right of the iterable, and move inwards, but this is not always the case, for instance: 26. Remove Duplicates from Sorted Array, initializes two pointers at the beginning, one to read and one to update. Two pointers is distinct from sliding window because we aren't considering all the values in the window, rather just the pointers. It is also different from binary since that is a more specific subset of two pointers.

prefix / postfixes - similar to kadane's, but the difference is we aren't resetting our prefix, we're just establishing cumulative prefixes and postfixes. Prefixes usually include the current number in the prefix, but they don't always have to for instance 238: Product of Array Except Self. Also 435: Non-overlapping intervals, our prefix represents the furthest end time of the prior intervals, but we use that to assess if we need to merge the new interval or not.

counting sort / bucket sort strategy - good for things that are bounded by what can be included, for instance sorting a word of only letters


18: 4sum.js has a good writeup on using `continue` / while loops
54: Maximum Subarray.js explains why we can reset the left wall of kadane's fully, instead of just doing l++
209: Minimum Size Subarray.js showcases how we decrement from l as much as possible until our constraint fails


// SLIDING WINDOW / KADANES / PREFIX STUFF
1) max sum of any subarray (any numbers, non sorted) - we can use kadane's prefix sums

2) minimum size of subarray of sum >=k (positive numbers, non sorted) - we can use sliding variable window, decrement from left pointer as much as possible when >=k, since we increment r immediately as well. We can't allow negative numbers since then we aren't sure if incrementing the left pointer of the window would cause our sum to increase.

3) max product of array (any numbers, not sorted) - we can use a minPrefix and maxPrefix sum



fix moves zeroes
TODO: is min size subarray sum>=k doable with a mapping, for negative numbers? what about the number of subarrays?