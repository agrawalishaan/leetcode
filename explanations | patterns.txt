kadane's - kadane's is very specifically a 'sliding window' technique where we iterate over an iterable and maintain a dp. If the dp doesn't meet some condition, we reset it in a way, effectively "moving" what would be our left pointer. Kadane's movement follows an inchworm, because when we don't meet a condition we reset the dp to some defined place. It's often easier to update the dp with the current index value immedaitely, then do computations with that, similar to how prefix sums usually include the current number as part of the prefix.

sliding window variable - these are more flexible, in that that the left pointer moves over by some other amount, depending on the problem. For instance finding the minimum size subarray that equals a certain sum (problem 209) consider [1, 3, 5] and our target is at least 6, once we hit [1,3,5] we keep decrementing from the left until we cannot any more. in sliding window we keep expanding until a condition is met (subarry has >= k sum) or broken (we have a repeating character), and then we shrink as much as needed (subarray too small) or (repeating character is gone). We could also just decrement from the left one at a time, and not increment the right. Generally sliding window variable problems will end with an r++ inside the main while loop, and inside the while loop we will decrement from the left until  constraint is hit.

two pointers - initialize two pointers that will be used to track or update things. Often, these are initialized at the left and right of the iterable, and move inwards, but this is not always the case, for instance: 26. Remove Duplicates from Sorted Array, initializes two pointers at the beginning, one to read and one to update. Two pointers is distinct from sliding window because we aren't considering all the values in the window, rather just the pointers. It is also different from binary since that is a more specific subset of two pointers. In general, two pointer problems will have have a forced increment at the beginning, and it is up to us to determine what to increment and when inside the loop. This is not always the case though, such as in the simple code for 283: Move Zeroes, where we start with two pointers from the beginning.

prefix / postfixes - similar to kadane's, but the difference is we aren't resetting our prefix, we're just establishing cumulative prefixes and postfixes. Prefixes usually include the current number in the prefix, but they don't always have to for instance 238: Product of Array Except Self. Also 435: Non-overlapping intervals, our prefix represents the furthest end time of the prior intervals, but we use that to assess if we need to merge the new interval or not.

counting sort / bucket sort strategy - good for things that are bounded by what can be included, for instance sorting a word of only letters


18: 4sum.js has a good writeup on using `continue` / while loops
54: Maximum Subarray.js explains why we can reset the left wall of kadane's fully, instead of just doing l++
209: Minimum Size Subarray.js showcases how we decrement from l as much as possible until our constraint fails


// SLIDING WINDOW / KADANES / PREFIX STUFF
1) max sum of any subarray (any numbers, non sorted) - we can use kadane's prefix sums

2) minimum size of subarray of sum >=k (positive numbers, non sorted) - we can use sliding variable window, decrement from left pointer as much as possible when >=k, since we increment r immediately as well. We can't allow negative numbers since then we aren't sure if incrementing the left pointer of the window would cause our sum to increase.

3) number of subarrays of sum=k or sum>=k (positive nums, not sorted), same as above, we can use a sliding window! once we are greater than or equal to the sum, we keep decrementing and adding to our count as long as we still fit the constraint

4) max product of array (any numbers, not sorted) - we can use a minPrefix and maxPrefix sum

a common motif with prefixes or dps or something (think trapping rainwater II my failed attempt at trying to get the row and column constraints when I first tried the Min(rowConstraint, colConstraint) strategy) is:
1- we know some information such as the max heights, this might happen immediately when we enter the loop because they are initialized before the loop starts
2- we use those max heights or that information to compute something
3- we update the new max
but also if our prefix should include the current cell, we might have a pattern like:
1- we dont yet know the information / we might have default values such as infinity or negative infinity
2- we reach a new cell and update the prefix or information based on that cell
3- we process something with that info such as the min length of the subarray


TODO: is min size subarray sum>=k doable with a mapping, for negative numbers? what about the number of subarrays?