Try DP from both directions.

In 2d dp, we sometimes don't need to allocate an entire matrix of memory. For instance in 62: Unique Paths, we start tabulating from the bottom right, moving left and up. Each dp cell is the sum of the one below it, and to the right. So we can just maintain a 1d array and overwrite within the same array as we tabulate.

Instead of using memoization for a 2d cache, like JSON.stringify([row, col]), it's usually faster to allocate a matrix instead, as stringification and hashtable dereferencing are slow. We can initialize values in the matrix to be a certain type to indicate they haven't been solved.

A common strategy in dp is to start iterating backwards, solving prior values based on future ones. For each prior value, we iterate through n future values. This is an n^2 solution but is used in many problems such as 1027: Longest Arithmetic Subsequence. We can also usually solve it from the beginning, looking at n prior elements (either left to right or right to left), but usually I like to solve from the back first.

If we are solving something like a 2d dp problem, we can allocate a larger array and store 0s or 1s or whatever we need on the edges, to prevent out of bounds cases. But sometimes it is easier to just check if we are out of bounds, because if we allocate a larger matrix the index conversion between the input grid and our larger allocation can be a bit confusing.