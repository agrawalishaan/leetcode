Try DP from both directions.

In 2d dp, we sometimes don't need to allocate an entire matrix of memory. For instance in 62: Unique Paths, we start tabulating from the bottom right, moving left and up. Each dp cell is the sum of the one below it, and to the right. So we can just maintain a 1d array and overwrite within the same array as we tabulate.

Instead of using memoization for a 2d cache, like JSON.stringify([row, col]), it's usually faster to allocate a matrix instead, as stringification and hashtable dereferencing are slow. We can initialize values in the matrix to be a certain type to indicate they haven't been solved.

A common strategy in dp is to start iterating backwards, solving prior values based on future ones. For each prior value, we iterate through n future values. This is an n^2 solution but is used in many problems such as 1027: Longest Arithmetic Subsequence. We can also usually solve it from the beginning, looking at n prior elements (either left to right or right to left), but usually I like to solve from the back first. We can also do this on some stock problems, for instance in buying and selling a stock with at most 2 transactions, our solution at a given ending index would be to buy a stock at that price, iterate through all future values, sell at a future value, and take the next dp which stores the results for buying and selling with only 1 transaction allowed. Or in buying and selling with transaction fee, we could take a value, assume we buy there, iterate through all future values, assume we sell at that future value, and add the dp on the right sub problem.

If we are solving something like a 2d dp problem, we can allocate a larger array and store 0s or 1s or whatever we need on the edges, to prevent out of bounds cases. But sometimes it is easier to just check if we are out of bounds, because if we allocate a larger matrix the index conversion between the input grid and our larger allocation can be a bit confusing.

State machines rely on updating values based on prior values. See the buy and sell stock problems (1-4, with transaction fee, with cooldown, for examples).