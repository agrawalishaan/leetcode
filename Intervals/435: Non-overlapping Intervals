// https://leetcode.com/problems/non-overlapping-intervals/description/
// Difficulty: Medium
// tags: greedy, prefix

// Solution
// O(nlogn) time and O(1) or O(n) space depending on your sort alg.
// Sort the interval list with a multikey sort, so the first number then the second, such as: [[1, 9], [1, 10], [2, 5], [7, 9]]
// At a given interval, the prefix represents the longest previous interval at that moment, and is used to detect an overlap. For instance at the beginning, our prefix is negative infinity, since we have no prior interval. So when we scan the very first interval, we know there is no overlap. Once we add a non-overlapping interval, like in [1,2] [3,4] and we add [3,4], we have to update our prefix to be 4. But what if there is an overlap? Say [1, 5] [2, 6], or [1, 5] [1, 4] or [1, 5] [2, 3], then we choose to keep the interval which ends first, since worst case it does as good as the interval that ends second. We also need to accordingly update the prefix to be the minimum. Important to note that the prefix can therefore move up or down.

const eraseOverlapIntervals = function (intervals) {
  intervals.sort((a, b) => {
    // -1 means a goes first
    if (a[0] < b[0]) {
      return -1; // first interval starts with a smaller number
    } else if (a[0] > b[0]) {
      return 1;
    } else if (a[0] === b[0]) {
      return a[1] - b[1];
    }
  });

  let totalToRemove = 0;
  let prevEnd = Number.NEGATIVE_INFINITY;
  // iterate over intervals
  for (let i = 0; i < intervals.length; i++) {
    const intervalCurrent = intervals[i];
    if (intervalCurrent[0] >= prevEnd) {
      prevEnd = intervalCurrent[1];
    } else {
      totalToRemove++;
      prevEnd = Math.min(prevEnd, intervalCurrent[1]);
    }
  }
  return totalToRemove;
};
